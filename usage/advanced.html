

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Advanced usage &mdash; PyMGRIT 0.1.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Dahlquist" href="../applications/dahlquist.html" />
    <link rel="prev" title="Parallelism" href="parallelism.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> PyMGRIT
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallelism.html">Parallelism</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Advanced usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#advanced-multigrid-hierarchy">Advanced multigrid hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spatial-coarsening">Spatial coarsening</a></li>
<li class="toctree-l2"><a class="reference internal" href="#convergence-criteria">Convergence criteria</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Applications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../applications/dahlquist.html">Dahlquist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/brusselator.html">Brusselator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/arenstorf_orbit.html">Arenstorf orbit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/heat_equation.html">Heat Equation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/advection.html">Advection</a></li>
</ul>
<p class="caption"><span class="caption-text">Coupling</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../coupling/firedrake.html">Firedrake</a></li>
</ul>
<p class="caption"><span class="caption-text">Help</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../help/faq.html">Frequently Asked Questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyMGRIT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Advanced usage</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/usage/advanced.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="advanced-usage">
<h1>Advanced usage<a class="headerlink" href="#advanced-usage" title="Permalink to this headline">¶</a></h1>
<p>This page contains short examples that demonstrate advanced usage of PyMGRIT.
The source code for these and more examples is available in the <a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples">examples</a> folder.</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#advanced-multigrid-hierarchy">Advanced multigrid hierarchy</a></p></li>
<li><p><a class="reference internal" href="#spatial-coarsening">Spatial coarsening</a></p></li>
<li><p><a class="reference internal" href="#convergence-criteria">Convergence criteria</a></p></li>
</ul>
</div></blockquote>
<div class="section" id="advanced-multigrid-hierarchy">
<h2>Advanced multigrid hierarchy<a class="headerlink" href="#advanced-multigrid-hierarchy" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_time_integrators.py">example_time_integrators.py</a> and <a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_heat_1d_bdf2.py">example_heat_1d_bdf2.py</a></p>
<p>PyMGRIT allows using different application classes and/or time integration schemes in the multigrid hierarchy.</p>
<ul class="simple">
<li><p>Example 1 shows how to implement different time integration methods in an application class.</p></li>
<li><p>Example 2 shows how to use multiple application classes in the multigrid hierarchy.</p></li>
</ul>
<p><strong>Example 1</strong> One application class with different time integration methods</p>
<p>The member function <cite>step()</cite> of an application class can carry out a time integration step based on different time
integration methods. The <a class="reference external" href="https://github.com/pymgrit/pymgrit/blob/master/src/pymgrit/dahlquist/dahlquist.py">Dahlquist
application class</a> implements the following time integration schemes:</p>
<ul class="simple">
<li><p>Backward Euler</p></li>
<li><p>Forward Euler</p></li>
<li><p>Trapezoidal rule</p></li>
<li><p>Implicit mid-point rule</p></li>
</ul>
<p>that can be controlled by the member variable <cite>method</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_start</span><span class="p">:</span> <span class="n">VectorDahlquist</span><span class="p">,</span> <span class="n">t_start</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorDahlquist</span><span class="p">:</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Time integration routine for Dahlquist&#39;s test problem:</span>
<span class="sd">    BE: Backward Euler</span>
<span class="sd">    FE: Forward Euler</span>
<span class="sd">    TR: Trapezoidal rule</span>
<span class="sd">    MR: implicit Mid-point rule</span>

<span class="sd">:param u_start: approximate solution for the input time t_start</span>
<span class="sd">:param t_start: time associated with the input approximate solution u_start</span>
<span class="sd">:param t_stop: time to evolve the input approximate solution to</span>
<span class="sd">:return: approximate solution for the input time t_stop</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_stop</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Note: lambda = -1</span>
<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;BE&#39;</span><span class="p">:</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_start</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>
<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;FE&#39;</span><span class="p">:</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_start</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>
<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;TR&#39;</span><span class="p">:</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">z</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_start</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>
<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;MR&#39;</span><span class="p">:</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">z</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_start</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">u_start</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">t_stop</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">k1</span>
<span class="k">return</span> <span class="n">VectorDahlquist</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
</pre></div>
</div>
<p>The corresponding example (<a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_time_integrators.py">example_time_integrators.py</a>) creates a two-level hierarchy for Dahlquist’s test problem, using the implicit mid-point
rule on the fine grid (level 0) and backward Euler on the coarse grid (level 1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create Dahlquist&#39;s test problem using implicit mid-point rule time integration</span>
<span class="n">dahlquist_lvl0</span> <span class="o">=</span> <span class="n">Dahlquist</span><span class="p">(</span><span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;MR&#39;</span><span class="p">)</span>
<span class="c1"># Create Dahlquist&#39;s test problem using backward Euler time integration</span>
<span class="n">dahlquist_lvl1</span> <span class="o">=</span> <span class="n">Dahlquist</span><span class="p">(</span><span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;BE&#39;</span><span class="p">)</span>

<span class="c1"># Setup an MGRIT solver and solve the problem</span>
<span class="n">mgrit</span> <span class="o">=</span> <span class="n">Mgrit</span><span class="p">(</span><span class="n">problem</span><span class="o">=</span><span class="p">[</span><span class="n">dahlquist_lvl0</span><span class="p">,</span> <span class="n">dahlquist_lvl1</span><span class="p">])</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">mgrit</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Example 2</strong> Two application classes</p>
<p>In the second example, we use two application classes for implementing two different
time integration methods for the 1D heat equation example:</p>
<ul class="simple">
<li><p>Application class 1 implements <a class="reference external" href="https://github.com/pymgrit/pymgrit/blob/master/src/pymgrit/heat/heat_1d_2pts_bdf2.py">BDF2</a>.</p></li>
<li><p>Application class 2 implements <a class="reference external" href="https://github.com/pymgrit/pymgrit/blob/master/src/pymgrit/heat/heat_1d_2pts_bdf1.py">BDF1</a>.</p></li>
</ul>
<p>Note: The <a class="reference external" href="https://github.com/pymgrit/pymgrit/blob/master/src/pymgrit/heat/vector_heat_1d_2pts.py">vector class</a> used in both application classes contains the solution at two consecutive time points.</p>
<p>The corresponding example (<a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_heat_1d_bdf2.py">example_heat_1d_bdf2.py</a>) constructs a three-level multigrid hierarchy for the 1D heat
equation example using the BDF2 application class on the fine grid (level 0) and the BDF1 application class on the
first and second coarse grids (levels 1 and 2):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Right-hand side of 1D heat equation example problem at a given space-time point (x,t)</span>
<span class="sd">    :param x: spatial grid point</span>
<span class="sd">    :param t: time point</span>
<span class="sd">    :return: right-hand side of 1D heat equation example problem at point (x,t)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">init_con_fnc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exact solution of 1D heat equation example problem at a given space-time point (x,t)</span>
<span class="sd">    :param x: spatial grid point</span>
<span class="sd">    :param t: time point</span>
<span class="sd">    :return: exact solution of 1D heat equation example problem at point (x,t)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="n">t_stop</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">nt</span> <span class="o">=</span> <span class="mi">512</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t_stop</span> <span class="o">/</span> <span class="n">nt</span>
<span class="n">t_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">nt</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">heat0</span> <span class="o">=</span> <span class="n">Heat1DBDF2</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">rhs</span><span class="p">,</span> <span class="n">init_con_fnc</span><span class="o">=</span><span class="n">init_con_fnc</span><span class="p">,</span>
                   <span class="n">t_interval</span><span class="o">=</span><span class="n">t_interval</span><span class="p">)</span>
<span class="n">heat1</span> <span class="o">=</span> <span class="n">Heat1DBDF1</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">rhs</span><span class="p">,</span> <span class="n">init_con_fnc</span><span class="o">=</span><span class="n">init_con_fnc</span><span class="p">,</span>
                   <span class="n">t_interval</span><span class="o">=</span><span class="n">heat0</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
<span class="n">heat2</span> <span class="o">=</span> <span class="n">Heat1DBDF1</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">rhs</span><span class="p">,</span> <span class="n">init_con_fnc</span><span class="o">=</span><span class="n">init_con_fnc</span><span class="p">,</span>
                   <span class="n">t_interval</span><span class="o">=</span><span class="n">heat1</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>

<span class="n">problem</span> <span class="o">=</span> <span class="p">[</span><span class="n">heat0</span><span class="p">,</span> <span class="n">heat1</span><span class="p">,</span> <span class="n">heat2</span><span class="p">]</span>
<span class="n">mgrit</span> <span class="o">=</span> <span class="n">Mgrit</span><span class="p">(</span><span class="n">problem</span><span class="o">=</span><span class="n">problem</span><span class="p">)</span>
<span class="n">mgrit</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="spatial-coarsening">
<h2>Spatial coarsening<a class="headerlink" href="#spatial-coarsening" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_spatial_coarsening.py">example_spatial_coarsening.py</a></p>
<p>This example shows how the transfer parameter of the MGRIT solver can be used to perform an additional spatial
coarsening on the different levels. We use the 1D heat equation (see <a class="reference internal" href="../applications/heat_equation.html"><span class="doc">Heat Equation</span></a>).</p>
<p>The first step is to import all necessary PyMGRIT classes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pymgrit.heat.heat_1d</span> <span class="kn">import</span> <span class="n">Heat1D</span>  <span class="c1"># 1D Heat equation problem</span>
<span class="kn">from</span> <span class="nn">pymgrit.heat.heat_1d</span> <span class="kn">import</span> <span class="n">VectorHeat1D</span>  <span class="c1"># 1D Heat equation vector class</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.mgrit</span> <span class="kn">import</span> <span class="n">Mgrit</span>  <span class="c1"># MGRIT solver</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.grid_transfer</span> <span class="kn">import</span> <span class="n">GridTransfer</span>  <span class="c1"># Parent grid transfer class</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.grid_transfer_copy</span> <span class="kn">import</span> <span class="n">GridTransferCopy</span>  <span class="c1"># Copy transfer class</span>
</pre></div>
</div>
<p>Then, we define the class GridTransferHeat for the 1D heat equation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GridTransferHeat</span><span class="p">(</span><span class="n">GridTransfer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Grid Transfer for the Heat Equation.</span>
<span class="sd">    Interpolation: Linear interpolation</span>
<span class="sd">    Restriction: Full weighted</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>
<span class="sd">        :rtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GridTransferHeat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
</pre></div>
</div>
<p>The grid transfer class must contain two member functions: <cite>restriction</cite> and <cite>interpolation</cite>.</p>
<p>The function restriction receives a VectorHeat1D object and returns another VectorHeat1D object, that contains
the restricted solution vector:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">restriction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">VectorHeat1D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorHeat1D</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Restrict u using full weighting.</span>

<span class="sd">    Note: The 1d heat equation example is with homogeneous Dirichlet BCs in space.</span>
<span class="sd">          The Heat1D vector class stores only the non boundary points.</span>
<span class="sd">    :param u: VectorHeat1D</span>
<span class="sd">    :rtype: VectorHeat1D</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the non boundary points</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>

    <span class="c1"># Create array</span>
    <span class="n">ret_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Full weighting</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)):</span>
        <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span>

    <span class="c1"># Create and return a VectorHeat1D object</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">VectorHeat1D</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">))</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>
</pre></div>
</div>
<p>The function interpolation works in the same way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">VectorHeat1D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorHeat1D</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate u using linear interpolation</span>

<span class="sd">    Note: The 1d heat equation example is with homogeneous Dirichlet BCs in space.</span>
<span class="sd">          The Heat1D vector class stores only the non boundary points.</span>
<span class="sd">    :param u: VectorHeat1D</span>
<span class="sd">    :rtype: VectorHeat1D</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the non boundary points</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>

    <span class="c1"># Create array</span>
    <span class="n">ret_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Linear interpolation</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)):</span>
        <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Create and return a VectorHeat1D object</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">VectorHeat1D</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">))</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>
</pre></div>
</div>
<p>Now, we construct our multilevel scheme building each level. In this example, we use four-level MGRIT. The finest level
has 17 points in space, the second level 9, the third level 5 and the fourth level also 5.</p>
<p>Note: In this example, it is not possible to use the PyMGRIT’s core function simple_setup_problem, since each level
has different spatial sizes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">heat0</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">heat1</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat0</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
<span class="n">heat2</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat1</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
<span class="n">heat3</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat2</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>

<span class="n">problem</span> <span class="o">=</span> <span class="p">[</span><span class="n">heat0</span><span class="p">,</span> <span class="n">heat1</span><span class="p">,</span> <span class="n">heat2</span><span class="p">,</span> <span class="n">heat3</span><span class="p">]</span>
</pre></div>
</div>
<p>Then, we have to define the transfer operator per grid level. The transfer operator is a list of lengths (#level -1) and
specifies the transfer operator used per level. For the transfer between the first and the second level,
an object of the class GridTransferHeat() is needed to transfer the solution between the different space grids with
different sizes. The same is necessary for the transfer between the second and third level. Since the third and fourth
level have the same size in space, the GridTransferCopy class from PyMGRIT’s core is used. Set up the MGRIT solver with
the problem and the transfer operators and solve the problem:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">transfer</span> <span class="o">=</span> <span class="p">[</span><span class="n">GridTransferHeat</span><span class="p">(),</span> <span class="n">GridTransferHeat</span><span class="p">(),</span> <span class="n">GridTransferCopy</span><span class="p">()]</span>
<span class="n">mgrit</span> <span class="o">=</span> <span class="n">Mgrit</span><span class="p">(</span><span class="n">problem</span><span class="o">=</span><span class="n">problem</span><span class="p">,</span> <span class="n">transfer</span><span class="o">=</span><span class="n">transfer</span><span class="p">)</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">mgrit</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Complete code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pymgrit.heat.heat_1d</span> <span class="kn">import</span> <span class="n">Heat1D</span>  <span class="c1"># 1D Heat equation problem</span>
<span class="kn">from</span> <span class="nn">pymgrit.heat.heat_1d</span> <span class="kn">import</span> <span class="n">VectorHeat1D</span>  <span class="c1"># 1D Heat equation vector class</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.mgrit</span> <span class="kn">import</span> <span class="n">Mgrit</span>  <span class="c1"># MGRIT solver</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.grid_transfer</span> <span class="kn">import</span> <span class="n">GridTransfer</span>  <span class="c1"># Parent grid transfer class</span>
<span class="kn">from</span> <span class="nn">pymgrit.core.grid_transfer_copy</span> <span class="kn">import</span> <span class="n">GridTransferCopy</span>  <span class="c1"># Copy transfer class</span>

<span class="k">class</span> <span class="nc">GridTransferHeat</span><span class="p">(</span><span class="n">GridTransfer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Grid Transfer for the Heat Equation.</span>
<span class="sd">    Interpolation: Linear interpolation</span>
<span class="sd">    Restriction: Full weighted</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>
<span class="sd">        :rtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GridTransferHeat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="c1"># Specify restriction operator</span>
    <span class="k">def</span> <span class="nf">restriction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">VectorHeat1D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorHeat1D</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restrict u using full weighting.</span>

<span class="sd">        Note: The 1d heat equation example is with homogeneous Dirichlet BCs in space.</span>
<span class="sd">              The Heat1D vector class stores only the non boundary points.</span>
<span class="sd">        :param u: VectorHeat1D</span>
<span class="sd">        :rtype: VectorHeat1D</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the non boundary points</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>

        <span class="c1"># Create array</span>
        <span class="n">ret_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Full weighting</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)):</span>
            <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span>

        <span class="c1"># Create and return a VectorHeat1D object</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">VectorHeat1D</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">))</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="c1"># Specify interpolation operator</span>
    <span class="k">def</span> <span class="nf">interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">VectorHeat1D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorHeat1D</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate u using linear interpolation</span>

<span class="sd">        Note: The 1d heat equation example is with homogeneous Dirichlet BCs in space.</span>
<span class="sd">              The Heat1D vector class stores only the non boundary points.</span>
<span class="sd">        :param u: VectorHeat1D</span>
<span class="sd">        :rtype: VectorHeat1D</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the non boundary points</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>

        <span class="c1"># Create array</span>
        <span class="n">ret_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Linear interpolation</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)):</span>
            <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ret_array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Create and return a VectorHeat1D object</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">VectorHeat1D</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ret_array</span><span class="p">))</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">ret_array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

<span class="n">heat0</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">heat1</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat0</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
<span class="n">heat2</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat1</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
<span class="n">heat3</span> <span class="o">=</span> <span class="n">Heat1D</span><span class="p">(</span><span class="n">x_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_interval</span><span class="o">=</span><span class="n">heat2</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>

<span class="n">problem</span> <span class="o">=</span> <span class="p">[</span><span class="n">heat0</span><span class="p">,</span> <span class="n">heat1</span><span class="p">,</span> <span class="n">heat2</span><span class="p">,</span> <span class="n">heat3</span><span class="p">]</span>

<span class="c1"># Specify a list of grid transfer operators of length (#level - 1)</span>
<span class="c1"># Using the new class GridTransferHeat to apply spatial coarsening on the first two levels</span>
<span class="c1"># Using the PyMGRIT&#39;s core class GridTransferCopy on the last level (no spatial coarsening)</span>
<span class="n">transfer</span> <span class="o">=</span> <span class="p">[</span><span class="n">GridTransferHeat</span><span class="p">(),</span> <span class="n">GridTransferHeat</span><span class="p">(),</span> <span class="n">GridTransferCopy</span><span class="p">()]</span>

<span class="c1"># Setup MGRIT solver with problem and transfer</span>
<span class="n">mgrit</span> <span class="o">=</span> <span class="n">Mgrit</span><span class="p">(</span><span class="n">problem</span><span class="o">=</span><span class="n">problem</span><span class="p">,</span> <span class="n">transfer</span><span class="o">=</span><span class="n">transfer</span><span class="p">)</span>

<span class="n">info</span> <span class="o">=</span> <span class="n">mgrit</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="convergence-criteria">
<h2>Convergence criteria<a class="headerlink" href="#convergence-criteria" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/pymgrit/pymgrit/tree/master/examples/example_example_convergence_criteria.py">example_convergence_criteria.py</a></p>
<p>In this example, we use a customized version of PyMGRIT’s MGRIT algorithm to change the convergence criteria. The first
step is to create a new class that inherits from the MGRIT class. Afterwards, we overwrite the convergence criteria
function that is called by the algorithm after each iteration. The new convergence criteria is the maximum norm of the
relative difference of two successive iterates at all C-points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MgritCustomized</span><span class="p">(</span><span class="n">Mgrit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Customized MGRIT with maximum norm of the relative</span>
<span class="sd">    difference of two successive iterates as convergence criteria</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cumstomized MGRIT constructor</span>
<span class="sd">        :param args:</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Call parent constructor</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MgritCustomized</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># New member variable for saving the C-points values of the last iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_it</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Initialize the new member variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_criteria</span><span class="p">(</span><span class="n">iteration</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convergence_criteria</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iteration</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stops if the maximum norm of the relative</span>
<span class="sd">        difference of two successive iterates</span>
<span class="sd">        at C-points is below the stopping tolerance.</span>
<span class="sd">        :param iteration: Iteration number</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create structure on the first function call</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_it</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_local_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_local_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_values</span><span class="p">())))</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_it</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># If process has a C-point</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_local_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Loop over all C-points of the process</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_local_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">new</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Compute relative difference between two iterates</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">new</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_it</span><span class="p">),</span> <span class="n">new</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_it</span><span class="p">),</span> <span class="n">where</span><span class="o">=</span><span class="n">new</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))))</span>

        <span class="c1"># Communicate the local value</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm_time</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="c1"># Maximum norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv</span><span class="p">[</span><span class="n">iteration</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
</pre></div>
</div>
<p>At last, we can use the new MGRITCustomized class to solve our problem in the usual way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create two-level time-grid hierarchy for the ODE system describing Arenstorf orbits</span>
<span class="n">ahrenstorf_lvl_0</span> <span class="o">=</span> <span class="n">ArenstorfOrbit</span><span class="p">(</span><span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mf">17.06521656015796</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">10001</span><span class="p">)</span>
<span class="n">ahrenstorf_lvl_1</span> <span class="o">=</span> <span class="n">ArenstorfOrbit</span><span class="p">(</span><span class="n">t_interval</span><span class="o">=</span><span class="n">ahrenstorf_lvl_0</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="mi">100</span><span class="p">])</span>

<span class="c1"># Use the customized MGRIT algorithm to solve the problem.</span>
<span class="c1"># Stopps if the maximum relative change in all four variables of arenstorf orbit is smaller than 1% for all C-points</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">MgritCustomized</span><span class="p">(</span><span class="n">problem</span><span class="o">=</span><span class="p">[</span><span class="n">ahrenstorf_lvl_0</span><span class="p">,</span> <span class="n">ahrenstorf_lvl_1</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../applications/dahlquist.html" class="btn btn-neutral float-right" title="Dahlquist" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="parallelism.html" class="btn btn-neutral float-left" title="Parallelism" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Jens Hahne

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>